t=5
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
z=-1
v=0
t=5
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
z=-1
v=0
t=10
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
z=-1
v=0
t=1
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
z=-1
v=0
t=5
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
z=-1
v=0
t=2
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
z=-2
v=-1
t=2
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
z=1
v=-1
t=2
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
z=1
v=-1
t=2
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
pmu=17.779
psd=3.7
p_tilde=(p-pmu)/psd
high=1
if(high){
z=1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
high=0
if(high){
z=1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
high=1
if(high){
z=1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
high=1
if(high){
z=1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
high=1
if(high){
z=1
v=-1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
high=1
if(high){
z=1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
high=0
if(high){
z=1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
high=1
if(high){
z=1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
high=1
if(high){
z=1
v=2
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
high=1
if(high){
z=2
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
high=1
if(high){
z=1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
high=1
if(high){
z=-1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
high=1
if(high){
z=-1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
high=1
if(high){
z=-1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
pmu=17.779
psd=3.7
p_tilde=(p-pmu)/psd
high=0
if(high){
z=-1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
pmu=17.779
psd=3.7
p_tilde=(p-pmu)/psd
high=0
if(high){
z=-1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
pmu=17.779
psd=3.7
p_tilde=(p-pmu)/psd
high=1
if(high){
z=-1
v=1
t=5
}else{
z=1
v=-1
t=2.5
}
psi=2*((t-5)^4/600+exp(-4*(t-5)^2)+t/10-2)
p=25+(z+3)*psi+v
pmu=17.779
psd=3.7
p_tilde=(p-pmu)/psd
?nnet
library("nnet")	#quicker multinomial logit
?nnet
x<-matrix(2,2,1)
View(x)
x<-matrix(c(2,2),1,1,1,1)
x<-matrix(c(2,2),1,1,1,1)
?matrix
x<-matrix(c(1,1,1,1),2,2)
eigen(x)
install.packages("mlbench")
library(mlbench)
data(Glass)
sample(1:nrow(Glass),30)
1:nrow(Glass)
1:nrow(Glass)
sample(1:nrow(Glass),30)
rm(list = ls())
library(mlbench)
data(Glass)
set.seed(80)
1:nrow(Glass)
drop_SI<-sample(1:nrow(Glass),30)
sample(1:nrow(Glass),30)
rm(list = ls())
# set up
library(mlbench)
data(Glass)
set.seed(80)
# randomly drop 30 values of SI and K
1:nrow(Glass)
index_drop_SI<-sample(1:nrow(Glass),30)
index_drop_K<-sample(1:nrow(Glass),30)
index_drop_SI
Glass$SI
rm(list = ls())
# set up
library(mlbench)
data(Glass)
set.seed(80)
# randomly drop 30 values of SI and K
1:nrow(Glass)
index_drop_Si<-sample(1:nrow(Glass),30)
index_drop_K<-sample(1:nrow(Glass),30)
Glass$Si
rm(list = ls())
# set up
library(mlbench)
data(Glass)
set.seed(80)
# randomly drop 30 values of SI and K
1:nrow(Glass)
index_drop_Si<-sample(1:nrow(Glass),30)
index_drop_K<-sample(1:nrow(Glass),30)
Glass$Si[index_drop_Si]<-NA
View(Glass)
index_drop_Si
Glass$Si
Glass$K[index_drop_K]<-NA
View(Glass)
index_drop_K
library(mice)
install.packages("mice")
?mice
??mice
md.pattern(Glass)
library(mice)
install.packages('mice')
library(mice)
install.packages("mice")
library(mice)
md.pattern(Glass)
md.pattern(Glass)
insta..packages('Hmisc')
install.packages('Hmisc')
library(Hmisc)
?Hmisc
??Hmisc
summary(Glass)
Glass_mean<-impute(Glass,fun=mean)
library(Hmisc)
library("Hmisc")
install.packages("Hmisc")
########
# set up
########
rm(list=ls())
library("foreign")
library("ggplot2")
library("quantreg")
library("glmnet")
library("nnet")
library("randomForest")
library("dplyr")
library("tibble")
library("tidyr")
library("MGLM")
library("multiwayvcov")
setwd("~/Documents/research/rrr_lasso_nielsen_blackbox")
#######################
# clean and format data
#######################
source('data_cleaning.R') #done
source('specifications.R') #in progress
milk_indicator=0 #0: soda, 1: milk
poly_degree=4 #degree of own price, income, interactions thereof
centering=1 #0: original data, 1: indirect componenets centered + scaled
data<-get_data(df,milk_indicator,poly_degree,centering) #specific to poly_degree=4 for grep
########
# set up
########
rm(list=ls())
########
# set up
########
rm(list=ls())
library("foreign")
library("ggplot2")
library("quantreg")
library("glmnet")
library("nnet")
library("randomForest")
library("dplyr")
library("tibble")
library("tidyr")
library("MGLM")
library("multiwayvcov")
setwd("~/Documents/research/rrr_lasso_nielsen_blackbox")
#######################
# clean and format data
#######################
source('data_cleaning.R') #done
source('specifications.R') #in progress
milk_indicator=0 #0: soda, 1: milk
poly_degree=4 #degree of own price, income, interactions thereof
centering=1 #0: original data, 1: indirect componenets centered + scaled
data<-get_data(df,milk_indicator,poly_degree,centering) #specific to poly_degree=4 for grep
hh=data[[1]]
t=data[[2]]
Ti=data[[3]]
Y=data[[4]]
regressors=data[[5]]
dregressors=data[[6]]
N=length(unique(hh))
sum_Ti=length(hh)
p=dim(regressors)[2]
##################
# helper functions
##################
source('primitives.R')
source('stage1.R')
#p0 used in low-dim dictionary in the stage 1 tuning procedure
p0=10
D_LB=0 #each diagonal entry of \hat{D} lower bounded by D_LB
D_add=0.2 #each diagonal entry of \hat{D} increased by D_add. 0.1 for 0, 0,.2 otw
max_iter=10 #max number iterations in Dantzig selector iteration over estimation and weights
###########
# algorithm
###########
set.seed(1) # for sample splitting
alpha_estimator=1
gamma_estimator=1
bias=1
#alpha_estimator: 0 dantzig, 1 lasso
#gamma_estimator: 0 dantzig, 1 lasso. only, since differentiable
#bias: 0 DML, 1 plug-in
# for debug of stage 2
#hh<-hh[1:1000]
#Y<-Y[1:1000]
#X<-regressors[1:1000,]
#dX<-dregressors[1:1000,]
source('stage2.R')
results<-rrr(hh,Y,regressors,dregressors,p0,D_LB,D_add,max_iter,alpha_estimator,gamma_estimator,bias)
printer(results)
for_tex(results)
#}
results[1]
results[2]
results[3]
########
# set up
########
rm(list=ls())
########
# set up
########
rm(list=ls())
library("foreign")
library("ggplot2")
library("quantreg")
library("glmnet")
library("nnet")
library("randomForest")
library("dplyr")
library("tibble")
library("tidyr")
library("MGLM")
library("multiwayvcov")
setwd("~/Documents/research/rrr_lasso_nielsen_blackbox")
#######################
# clean and format data
#######################
source('data_cleaning.R') #done
source('specifications.R') #in progress
milk_indicator=1 #0: soda, 1: milk
poly_degree=4 #degree of own price, income, interactions thereof
centering=1 #0: original data, 1: indirect componenets centered + scaled
data<-get_data(df,milk_indicator,poly_degree,centering) #specific to poly_degree=4 for grep
hh=data[[1]]
t=data[[2]]
Ti=data[[3]]
Y=data[[4]]
regressors=data[[5]]
dregressors=data[[6]]
N=length(unique(hh))
sum_Ti=length(hh)
p=dim(regressors)[2]
##################
# helper functions
##################
source('primitives.R')
source('stage1.R')
#p0 used in low-dim dictionary in the stage 1 tuning procedure
p0=10
D_LB=0 #each diagonal entry of \hat{D} lower bounded by D_LB
D_add=0.2 #each diagonal entry of \hat{D} increased by D_add. 0.1 for 0, 0,.2 otw
max_iter=10 #max number iterations in Dantzig selector iteration over estimation and weights
###########
# algorithm
###########
set.seed(1) # for sample splitting
alpha_estimator=1
gamma_estimator=1
bias=1
#alpha_estimator: 0 dantzig, 1 lasso
#gamma_estimator: 0 dantzig, 1 lasso. only, since differentiable
#bias: 0 DML, 1 plug-in
# for debug of stage 2
#hh<-hh[1:1000]
#Y<-Y[1:1000]
#X<-regressors[1:1000,]
#dX<-dregressors[1:1000,]
source('stage2.R')
results<-rrr(hh,Y,regressors,dregressors,p0,D_LB,D_add,max_iter,alpha_estimator,gamma_estimator,bias)
printer(results)
for_tex(results)
#}
results[1]
results[2]
results[3]
